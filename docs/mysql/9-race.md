---
layout: default
title: "[MySQL] 레이스"
parent: MySQL
nav_order: 9
---


# 레이스가 난다


# 레이스가 난다

“레이스가 난다”는 말은 **동시에 두 개 이상의 트랜잭션이 같은 자원(행/가격/재고/카트)을 다루면서, 처리 순서에 따라 결과가 달라져 버리는 상황**을 말해요. 주문 로직에서 특히 자주 터집니다.

# 어디서 레이스가 생기나

지금 흐름에서 핵심은 **계산을 트랜잭션 밖에서 하고, 락 없이 읽은 데이터로 주문을 확정**하려는 순간이에요.

1. 합계 계산을 트랜잭션 밖에서 함
    
2. 그 사이에 다른 트랜잭션이 장바구니/가격/재고를 수정
    
3. 내 트랜잭션이 뒤늦게 시작해 주문/차감/삭제를 수행  
    → **내가 본 값과 실제 커밋 시점의 값이 달라짐** (정합성 깨짐)
    

# 타임라인 예시

두 사용자가 아니라, 같은 사용자라도 **두 요청이 거의 동시에** 들어오면 문제가 납니다.

- T0: 트랜잭션 A가 `calc_cart_totals`를 **락 없이** 수행 → 총액 30,000원
    
- T1: 트랜잭션 B가 먼저 시작해서 같은 카트 일부 수량을 변경/삭제하고 커밋
    
- T2: 트랜잭션 A가 이제야 `START TRANSACTION` → A가 믿던 카트 상태가 이미 변함
    
- T3: A는 “30,000원”으로 주문 생성/차감/삭제 시도 →
    
    - 배송비 무료 임계치가 깨져 배송비가 붙어야 하는데도 안 붙거나,
        
    - 재고가 부족한데도 차감 시도,
        
    - 이미 삭제된 cart_id를 또 삭제하려 하면서 실패/불일치 발생
        

# 증상들

- **PRICE_CHANGED** 자주 발생 (프런트 표시 금액 vs 서버 재계산 금액 상이)
    
- **재고 부족/음수** 또는 무결성 제약 위반
    
- **카트 삭제 0건**(ROW_COUNT=0) → 이미 다른 트랜잭션이 지움
    
- 간헐적 **Deadlock**(잠금 순서가 엇갈릴 때)
    

# 왜 `FOR UPDATE`가 해결책인지

`SELECT … FOR UPDATE`는 **조회된 행을 배타 잠금**합니다.  
주문 트랜잭션 안에서:

1. **선택된 카트 행을 먼저 잠그고**(다른 트랜잭션이 수정/삭제 못 함)
    
2. **그 잠금 상태에서 합계를 다시 계산**(가격/배송비/임계치 포함)
    
3. 계산 결과로 주문/차감/삭제를 수행  
    → 내가 커밋할 때까지 **데이터가 바뀌지 않으므로** 레이스가 사라짐.

# 원칙 (요약)

1. `START TRANSACTION;`
    
2. **선택된 카트 행 `FOR UPDATE`로 잠금**
    
3. (잠금 상태) **합계 재계산/검증**
    
4. **주문상세 INSERT** (카트기반)
    
5. **장바구니 선택행 DELETE** (같은 트랜잭션)
    
6. `COMMIT;`
# 왜 이렇게?

- **락 후 재계산**: 락 없이 계산하면 그 사이 다른 트랜잭션이 카트를 바꿔 “레이스”가 납니다.
    
- **상세 INSERT 이후 삭제**: 주문상세가 확정된 항목만 지우기 위함(실패 시 롤백으로 되돌리기 쉬움).
    
- **조건에 user_id 포함**: 타 유저 카트 오삭제 방지.
    

# 체크리스트

- 인덱스: `shop_cart(user_id, seq_no)` 복합 인덱스 권장 → 필요한 행만 잠금.
    
- JSON 포맷: 객체/숫자 배열 혼용 가능하도록 파싱(위 UNION ALL).
    
- 일관된 잠금 순서(항상 cart → product …)로 데드락 확률 낮추기.
    
- `ROW_COUNT()` 체크는 **DELETE 직후**에만 — 중간에 다른 쿼리 끼우지 않기.
    
- 바로구매(direct) 경로는 카트 삭제가 없어야 함(분기 처리).

# 올바른 순서(요약)
```sql
START TRANSACTION;
SELECT ... FROM shop_cart ... FOR UPDATE;   -- 카트 행 잠금
-- (필요하면 상품/재고도 FOR UPDATE)
CALL calc_cart_totals(...)                  -- 락 잡힌 상태에서 재계산
IF 금액 불일치 THEN SIGNAL;
INSERT shop_orders ...;                     -- 주문 헤더
INSERT shop_order_product ...;              -- 상세 (카트 기반)
DELETE FROM shop_cart ...;                  -- 선택 카트 삭제
COMMIT;

```