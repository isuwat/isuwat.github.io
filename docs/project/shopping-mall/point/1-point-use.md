---
layout: default
title: "[point] 적립금 사용"
parent: point
nav_order: 1
---

# 적립금 사용


# 전체 개요

- **언제 실행?** order_form.php 페이지 로드 직후 즉시 실행(IIFE).
    
- **무엇을 하나?**
    
    1. 초기 한 번, 각 “총 결제금액 표시 엘리먼트”의 **원본 합계**를 `data-base`로 저장(스냅샷).
        
    2. 사용자가 적립금을 입력/전액사용 클릭할 때마다:
        
        - 입력값을 안전 범위로 **보정(clamp)**,
            
        - **마이너스 라인**(사용 적립금 표시)을 갱신,
            
        - **모든 총액 표시 요소(버튼/본문)**에 `최종 결제금액 = 원본합계 - 사용액`을 즉시 반영.
            

# 주요 요소/상수

- `$input`: `#use_point` — 사용자 입력칸
    
- `$btnAll`: `#btnPointAll` — 전액사용 버튼
    
- `$used`: `#ec-shop-payment_used_mileage_view` — “- 사용 적립금”에 찍힐 숫자(span)
    
- `$has`: `#point_has` — 보유 포인트(서버에서 `data-has`로 내려줌)
    
- `TOTAL_IDS`: 총 결제금액을 표시하는 **후보 id들의 배열**
    
    - 예: `total_order_sale_price_view`(버튼 안), `payment_total_order_sale_price_view`(본문), 등
        
    - 페이지에 존재하는 것들만 자동으로 사용
        

# 헬퍼

- `onlyNumber(s)`: “12,345원” 같이 섞인 문자열에서 **숫자만 뽑아 정수로**.
    
- `fmt(n)`: **천단위 콤마**로 표시용 문자열 생성.
    

# 스냅샷(snapshotBases)

- **왜 필요?** 총액 표시를 계속 덮어쓰면, 다음 계산 때 “덮어쓴 값”을 다시 빼는 **이중 차감**이 발생할 수 있음.
    
- **어떻게?** 각 총액 요소의 **초기 표시값**을 `data-base` 속성에 저장해 **‘원본’**으로 삼고, 이후 계산은 항상 이 값을 기준으로 함.
    

# getBase

- **무엇을 반환?** 기준이 되는 “원본 합계”.
    
- **어떻게 찾나?** `TOTAL_IDS` 순서대로 요소를 보며 `data-base`(없으면 현재 텍스트)를 읽음. 첫 번째로 유효한 값을 사용.
    

# getHas

- `#point_has`의 `data-has` 또는 텍스트에서 **보유 포인트** 숫자 반환.
    

# clamp(v)

- 입력된 사용 적립금을 **안전 구간**으로 보정:
    
    - `0 ≤ 사용액 ≤ 보유 포인트 ≤ 원본 합계`
        
- 즉, **보유 초과/총액 초과 방지**.
    

# render (핵심 갱신 루틴)

1. `base`(원본 합계), `used`(보정된 입력값), `final = base - used` 계산.
    
2. **입력칸**(우측 정렬 숫자)에 보정값을 되돌려 반영(사용자가 999999를 넣어도 안전).
    
3. **마이너스 라인** `#ec-shop-payment_used_mileage_view`에 `used`를 콤마로 표시.
    
4. **모든 총액 표시 요소**(`TOTAL_IDS`로 찾은 배열)를 순회하며 **표시 텍스트를 `final`로 통일 갱신**.
    
5. 전액사용 버튼 활성/비활성(보유=0 또는 base=0이면 비활성).
    

# 이벤트 흐름

- `input` 이벤트 → `render()`  
    (사용자가 숫자를 직접 치면 즉시 보정/반영)
    
- 전액사용 버튼 클릭 → `use_point`를 `min(보유, 원본합계)`로 채우고 `render()`  
    (클릭 즉시 버튼/본문 총액과 마이너스 라인 동시 반영)
    
- 로드 직후 → `snapshotBases()` → `render()` 한 번  
    (초기 화면 정리: 마이너스 라인 0, 총액 그대로)
    

# 왜 “지금은 즉시 반영”이 잘 되나?

- 예전에는 “submit 직전 보정”만 했다면, 지금은 **클릭/입력 시점에도** `render()`가 **버튼/본문 총액을 동시에 갱신**하므로, 전액사용 누르는 순간 화면 전체가 바로 바뀝니다.
    

# 확장/응용 포인트

- **총액 표시 엘리먼트가 추가**되면 `TOTAL_IDS`에 id만 더 넣으면 자동 반영.
    
- **서버 전송 값(hidden) 동기화**가 필요하면 `render()` 끝에서

```js
setHidden(form, 'use_point', used);
setHidden(form, 'final_amount_hint', final);

```

- 같은 2~3줄만 추가하면 됩니다.
    
- **총액을 절대 건드리지 않고 마이너스 라인만 갱신**하고 싶다면, `render()`에서 “총액 갱신” 부분만 제거하면 됩니다.

# 자주 묻는 점

- **Q. 왜 `data-base`를 쓰나?**  
    초기 금액을 기준으로만 계산해야 **중복 차감 방지**가 됩니다.
    
- **Q. 총액 id가 한 개뿐인데?**  
    `TOTAL_IDS`를 그 하나만 남겨도 OK. (코드 더 간결)
    
- **Q. 테마가 use_point 변경을 감지해 독자적으로 총액 재계산하면?**  
    지금처럼 **우리가 즉시 덮어써서** 의도대로 보여주면 대부분 충돌 없이 맞습니다. 그래도 충돌하면 이벤트 전파 차단(`e.stopPropagation()`)을 입력 이벤트에 추가하는 방법도 있습니다.