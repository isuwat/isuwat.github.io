---
layout: default
title: "[order] 최종 결제 금액 검증"
parent: order
nav_order: 4
---



# 최종 결제 금액 검증

**반드시 프로시저(서버)에서 다시 검증/재계산해야 합니다.**  
`order_form.php`가 가져온 합계(배송비 포함)는 “표시/안내용”이고, **최종 결제 금액의 진실은 DB 트랜잭션 안에서 재계산한 값**이어야 해요.


# 왜 재검증이 필요한가

- **신뢰 경계**: 프론트/웹서버 전달값은 조작 가능(총액, 할인, 배송비).
    
- **경합 조건**: 합계 조회 시점 ↔ 주문 생성 시점 사이에  
    가격 변경, 재고 변동, 쿠폰/프로모션 소진, 무료배송 임계치 변화 등이 발생 가능.
    
- **정책 일관성**: 주소 변경·배송정책(묶음배송/도서산간)·포인트/캐시 적용 규칙 등은 항상 **DB 기준**으로 계산되어야 함.
    
- **반올림/부가세**: 금액 반올림, 부가세 포함/별도 정책 불일치 방지.
    
- **법/회계 증빙**: 주문 레코드에 남는 금액은 서버 계산이 권고(감사 가능성).
    

# 권장 구현 패턴

1. **트랜잭션 시작**
    
    - `START TRANSACTION;`
        
2. **장바구니 행/상품 행 잠금**
    
    - 선택 구매라면 `SELECT ... FROM shop_cart ... FOR UPDATE`
        
    - 필요 시 `products/pricing`도 잠금 또는 스냅샷 테이블 사용
        
3. **서버 측 재계산**
    
    - 상품가(옵션/세트가 포함), 수량, 쿠폰/프로모션(유효성/중복/사용횟수), 포인트/캐시, 배송비(주소/묶음/무게/무료배송 기준) 모두 **프로시저 내부**에서 계산
        
4. **클라이언트 전달 총액과 비교**
    
    - 완전 불일치 시:  
        a) **차이 발생 에러 리턴**(예: `PRICE_CHANGED`, 서버 계산 금액을 OUT 값으로 전달) 또는  
        b) **클라이언트 값 무시**하고 **서버 계산 금액**으로 진행(대신 프론트에 알림 필요)
        
    - 소수점 오차가 있는 통화라면 **미세 허용 오차(예: 1원)**만 인정
        
5. **주문 생성(헤더/디테일) → 장바구니 삭제 → 결제 레코드 연결** 후 `COMMIT`
    
6. **불일치/오류 시 `ROLLBACK` + 정형화된 에러코드/메시지** 반환

## 왜 다시 계산해야 해?

- **경합·시차**: 조회 후 결제 직전까지 가격/재고/프로모션/배송정책이 바뀔 수 있어요.
    
- **신뢰 경계**: `order_form.php`가 넘기는 금액은 클라이언트→API 경로에서 조작 가능.
    
- **정책 일관성/회계**: 최종 청구 금액은 반드시 DB 트랜잭션 안의 로직이 “사실”이어야 함.
    
- **배송비/쿠폰 의존성**: 주소·무게·무료배송 임계치·쿠폰 사용가능 여부는 순간에 따라 달라짐.
    

## 권장 패턴

1. **프로시저 입력은 금액이 아니라 식별자 위주**
    
    - `pi_cart_ids_json`, `pi_user_id`, `pi_address_id`, `pi_coupon_ids`, `pi_point_to_use` 등.
        
    - `pi_client_total`(프론트 합계)는 **참조/검증용**으로만 받고, 계산은 서버가 한다.
        
2. **트랜잭션 + 잠금**
```sql
START TRANSACTION;

-- 선택된 카트 행 잠금
WITH selected_ids AS (
  SELECT CAST(j.cid AS UNSIGNED) AS cart_id
  FROM JSON_TABLE(pi_cart_ids_json, '$[*]' COLUMNS (cid INT PATH '$')) j
)
SELECT 1
FROM shop_cart c
JOIN selected_ids s ON s.cart_id = c.cart_id
WHERE c.user_id = pi_user_id
FOR UPDATE;

```

3. **서버측 재계산**
    
    - 상품가(옵션 포함)×수량, 쿠폰/프로모션, 포인트, **배송비**까지 전부 서버에서 산출.
        
4. - **불일치 처리**
```sql
IF v_server_total <> pi_client_total THEN
  -- A: 중단하고 새 금액 리턴 (PRICE_CHANGED)
  SIGNAL SQLSTATE '45000'
    SET MYSQL_ERRNO = 2101, MESSAGE_TEXT = 'PRICE_CHANGED';
  -- 또는 B: 서버 금액으로 진행하되 OUT 파라미터로 고지
END IF;

```

5. **주문 생성 → 장바구니 삭제 → COMMIT** (모두 한 트랜잭션)
    

## 성능/안전 타협안(옵션)

- **버전/체크섬 비교**: 카트 합계 산출 시 `cart_total_hash`, `cart_version`, `last_calc_at` 저장 → 프로시저에서 동일한지 먼저 확인. 다르면 재계산/실패.
    
- **스냅샷 필드**: 주문 상세에 `unit_price_snapshot`, `option_name_snapshot` 저장(사후 가격 변경 영향 차단).
    
- **허용 오차**: 통화 반올림 이슈만 허용(±1원 등).
    

---

### 결론

“카트에서 조회된 값”이라도 **최종은 서버 트랜잭션에서 재계산·검증**이 정석입니다.  
입력 금액은 참고용으로 받고, **식별자 기반 재조회+FOR UPDATE**로 일관성 보장하세요.