---
layout: default
title: "[cart] 왜 결제 전에 장바구니를 지우나"
parent: cart
nav_order: 16
---


결제 전(insert) 프로시저에서 장바구니를 삭제”하는 건 단순 정리 차원이 아니라 **동시성·정합성·중복방지**를 위한 핵심 설계예요. 정리하면:

# 왜 결제 전에 장바구니를 지우나?

1. **중복 주문 방지(멱등성 확보)**
    

- 주문헤더/상세를 생성한 직후 같은 장바구니가 남아 있으면, 사용자가 뒤로가기·새 탭·재시도 등으로 **같은 장바구니를 다시 주문**해버릴 수 있어요.
    
- 같은 트랜잭션에서 장바구니를 삭제하면 “그 장바구니 → 이 주문으로 이미 소비됨”이 보장되어 **insert 재호출 시 중복 주문을 원천 차단**합니다. (멱등키 `mTrdNo`가 있어도, 장바구니가 남아 있으면 중복 시나리오 여지가 커집니다.)
    

2. **소스 오브 트루스(Single Source of Truth) 전환**
    

- 결제에 들어간 순간, 장바구니는 더 이상 기준 데이터가 아니고 **주문상세가 기준**이 됩니다.
    
- 장바구니를 지우면 “주문 진행 중인 품목”을 **카트에서 편집/증가** 같은 행위로 어긋나게 만들 여지를 제거합니다.
    

3. **동시성 제어 범위 축소**
    

- 결제 후(update) 단계까지 장바구니를 붙잡아 두면 “카트 + 주문” 두 개 객체를 **오래 잠그는 구조**가 됩니다.
    
- 결제 전(insert)에서 **FOR UPDATE로 검증 → 주문생성 → 카트삭제 → 커밋**까지 한 번에 처리하면, **락 홀드 시간을 단축**하고 교착·경합을 줄입니다.
    

4. **재시도/장애 복구 단순화**
    

- insert가 실패하면 **전체 롤백**되므로 장바구니도 원상복구(삭제가 롤백됨).
    
- insert가 성공했다면 이미 주문으로 스냅샷이 떠졌으므로, 이후 PG 단계 실패는 **주문 상태 전이(결제실패/만료)** 로 처리하는 게 맞고, 카트와 이중 관리할 필요가 없습니다.
    

5. **다중 탭/다중 디바이스 시나리오 방어**
    

- 사용자가 같은 계정으로 두 탭에서 동시에 결제 눌러도, 첫 트랜잭션이 카트를 소비(삭제)하면 두 번째 트랜잭션은 **유효 카트 없음**으로 막혀 **이중주문**이 차단됩니다.
    

# “결제 실패하면 카트가 사라지지 않나?”에 대한 대응

운영 정책에 따라 선택지 두 가지:

A) **하드 삭제 + 복구 로직**

- 결제 실패/만료 시 **주문 → 카트 복원**(재담기) API/잡을 둡니다.
    
- 장점: 중복 주문 방지에 가장 강력.
    
- 단점: 복원 구현 필요.
    

B) **소프트 삭제/잠금(locked/in_checkout)**

- 카트 row에 `in_checkout=1`, `locked_until` 같은 필드를 두고 결제 전엔 **편집/재주문 불가** 상태로 전환.
    
- 결제 성공 시 실제 삭제, 실패/타임아웃 시 잠금 해제.
    
- 장점: 사용성(카트 유지) 좋은 편.
    
- 단점: 상태 기계가 늘어나고, 락 만료 처리(배치/워커) 필요.
    

둘 중 어떤 방식이든, **사용자 경험(실패율, 재시도 빈도)** 과 **운영 복잡도**의 트레이드오프로 결정합니다. 결제 실패율이 낮고 중복주문 리스크를 강하게 막고 싶다면 현재처럼 **결제 전 하드 삭제**가 깔끔합니다. 실패율이 높거나 “다시 담아주세요”가 불편하면 **소프트잠금→성공 시 삭제**가 좋습니다.

# 재고/예약과의 관계(중요)

- 카트 삭제만으로 **재고가 예약되는 건 아닙니다**.
    
- 재고 일시 예약이 필요하면, insert 단계에서
    
    - (1) **재고 차감(가예약)** → 결제 실패/만료 시 원복, 또는
        
    - (2) **예약 테이블**(stock_reservations) 기록 → 성공 시 확정, 실패 시 해제  
        전략이 꼭 들어가야 합니다.
        

# 현재 두-프로시저 구조와의 궁합

- **insert(결제 전)**: `FOR UPDATE`로 카트·상품·쿠폰/포인트 등 검증 → 주문헤더/상세 생성 → **카트 삭제** → 커밋
    
    - 여기서 멱등성(중복주문 방지)과 데이터 기준 전환을 완료.
        
- **update(결제 후)**: 주문 레코드만 잠그고 PG 응답(금액·서명·중복) 검증 → 상태 전이/로그 → 커밋
    
    - 카트는 이미 관여 X → 결제 후 단계가 가볍고 안전.
        

# 실무 팁

- 멱등키(`mTrdNo`/`order_number`) + **카트 삭제**를 같이 쓰면 중복주문 방지에 가장 강합니다.
    
- 결제 실패 복구 UX 필요 시: “최근 실패 주문 → 재담기” 버튼을 주문상세에 제공(주문상세의 items_json을 카트 API에 보내 재구성).
    
- 소프트잠금 방식을 쓰면 **타임아웃/크론**을 반드시 넣어 잠금 누적을 방지하세요.
    

요약: **결제 전 카트 삭제**는 “카트→주문”으로 소유권을 이전하고, **중복 주문/경합/편집 충돌**을 원천 차단하기 위한 선택입니다. 실패 UX를 어떻게 설계하느냐에 따라 **하드 삭제+복구** 또는 **소프트잠금→성공 시 삭제**